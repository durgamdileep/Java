package com.dileep.Streams.Hard.MainClasses;

import com.dileep.Streams.Hard.Model.*;

import java.time.LocalDate;
import java.util.*;
import java.util.stream.Collectors;


public class Main05102025 {
    public static  String indent(int level){
        return " ".repeat(level);
    }
    public static  void main(String[] args){

        /**
         * write logic to:
         *
         * Group transactions by their type.
         * For each type, partition the transactions into successful and non-successful (based on status.equals("SUCCESS")).
         * For each partition, calculate the total sum of amounts.
         * Return the result as a Map<String, Map<Boolean, Double>>,
         * where the outer map key is the transaction type, and the inner map key is true for success, false otherwise, and
         * the value is the sum of amounts.
         */
        List<Transaction> transactions = Arrays.asList(
                new Transaction("T1","user1","DEPOSIT", 1000.0, "SUCCESS"),
                new Transaction("T2", "user2","WITHDRAWAL", 500.0, "FAILED"),
                new Transaction("T3", "user3","DEPOSIT", 2000.0, "PENDING"),
                new Transaction("T4", "user1","TRANSFER", 1500.0, "SUCCESS"),
                new Transaction("T5", "user2","WITHDRAWAL", 700.0, "SUCCESS"),
                new Transaction("T6", "user1","TRANSFER", 3000.0, "FAILED"),
                new Transaction("T7", "user1","DEPOSIT", 1200.0, "SUCCESS"),
                new Transaction("T8", "user3","TRANSFER", 800.0, "SUCCESS"),
                new Transaction("T9", "user2","WITHDRAWAL", 200.0, "PENDING")
        );


        Map<String, Map<Boolean, Double>> finalTransactionDetails = transactions.stream()
                .collect(Collectors.groupingBy(transaction -> transaction.getType(),
                        Collectors.partitioningBy(t -> t.getStatus().equalsIgnoreCase("SUCCESS"),
                                Collectors.summingDouble(t -> t.getAmount())
                        )
                ));
        finalTransactionDetails.forEach((type,details)->{
            System.out.println(type +" : {");
            System.out.println("Transaction : {");
            details.forEach((b,amount)->{
                System.out.println( (b)? " SUCCESS :"+ amount  : " FAILED : "+ amount);
            });
            System.out.println("      } ");
            System.out.println(" } "+"\n");
        });



        /**
         * Use Java Streams (preferably .parallelStream()) to calculate the total amount of successful transactions per user.
         *
         * Return a Map<String, Double> where:
         * Key = userId
         * Value = sum of amounts of successful transactions for that user.
         */
        Map<String, Double> success = transactions.stream()
                .filter(t -> t.getStatus().trim().equalsIgnoreCase("success"))
                .collect(Collectors.groupingBy(t -> t.getUserId(),
                        Collectors.summingDouble(t -> t.getAmount())));
        System.out.println("Total amount of successful transactions per user:\n{");
        success.forEach((user, amount) -> {
            System.out.println(indent(1) + "User ID   : " + user);
            System.out.println(indent(1) + "Total Amt : " + amount);
            System.out.println();
        });
        System.out.println("}");


        /**
         * write logic to:
         *
         * Find the total revenue generated by each customer.
         * Revenue for an order = sum over all items: quantity * pricePerUnit
         * Return a Map<String, Double> where the key is customerId and the value is the total revenue.
         */
        List<Order> orders = Arrays.asList(
                new Order("O1", "C1", Arrays.asList(
                        new Item("P1", 2, 50.0),
                        new Item("P2", 1, 150.0)
                ), LocalDate.of(2024, 1, 10)),

                new Order("O2", "C2", Arrays.asList(
                        new Item("P3", 3, 30.0),
                        new Item("P4", 5, 20.0)
                ), LocalDate.of(2024, 2, 5)),

                new Order("O3", "C1", Arrays.asList(
                        new Item("P2", 2, 150.0),
                        new Item("P5", 1, 200.0)
                ), LocalDate.of(2024, 3, 15)),

                new Order("O4", "C3", Arrays.asList(
                        new Item("P6", 4, 25.0)
                ), LocalDate.of(2024, 3, 20)),

                new Order("O5", "C2", Arrays.asList(
                        new Item("P1", 1, 50.0),
                        new Item("P7", 3, 70.0)
                ), LocalDate.of(2024, 4, 1))
        );

        Map<String, Double> revenueOfCustomer = orders.stream()
                .collect(Collectors.groupingBy(order -> order.getCustomerId(),
                                Collectors.flatMapping(order -> order.getItems().stream()
                                        .map(item -> item.getQuantity() * item.getPricePerUnit()),
                                         Collectors.summingDouble(v -> v))
                        )
                );
        /**
         *  other way by using summingDouble directly
         */
        orders.stream()
                .collect(Collectors.groupingBy(order -> order.getCustomerId(),
                                Collectors.summingDouble(order -> order.getItems().stream()
                                        .mapToDouble(item -> item.getQuantity() * item.getPricePerUnit())
                                        .sum())
                        )
                );
        System.out.println("Find the total revenue generated by each customer : \n"+ " { ");
        revenueOfCustomer.forEach((customer,amount)->{

            System.out.println( "     Customer : "+ customer);
            System.out.println( "     Amount : "+ amount);
            System.out.println();
        });
        System.out.println(" } \n");


        /**
         * write logic to:
         *
         * Group students by their grade.
         * For each grade, find the student with the highest average score.
         * Return the result as a Map<Integer, Optional<Student>>
         * Key = grade
         * Value = student with highest average score in that grade
         */
        List<Student> students = Arrays.asList(
                new Student("Alice", 10, Arrays.asList(85, 90, 78)),
                new Student("Bob", 10, Arrays.asList(70, 75, 80)),
                new Student("Charlie", 11, Arrays.asList(95, 88, 92)),
                new Student("David", 11, Arrays.asList(85, 86, 90)),
                new Student("Eva", 12, Arrays.asList(100, 98, 97)),
                new Student("Frank", 12, Arrays.asList(60, 65, 70))
        );
        Map<Integer, Optional<Student>> finalStudentDetails = students.stream()
                .collect(Collectors.groupingBy(student -> student.getGrade(),
                        Collectors.maxBy(Comparator.comparingDouble(s -> s.getScores().stream().mapToInt(i -> i).average().orElse(0.0)))
                ));
        System.out.println("Group students by their grade.\n" +
                "For each grade, find the student with the highest average score. \n"+ " { ");
        finalStudentDetails.forEach((grade,student)->{

            System.out.println( "     Grade : "+ grade);
            System.out.println( "     Student : "+ student.map(s-> s.getName()+"\n "+ "    Scores: "+ s.getScores()+ "\n"+ "     Average : "+ s.getScores().stream().mapToDouble(i-> i).average().orElse(0.0)).orElse("No Student"));
            System.out.println();
        });
        System.out.println(" } \n");


        /**
         * write logic to:
         *
         * Group all books by their publication year
         * For each year, extract all unique genres of books published in that year
         * Return result as: Map<Integer,Set<String>>
         * Key = year
         * Value = set of unique genres for books published in that year
         */
        List<Book> books = Arrays.asList(
                new Book("The Last Empire", "John Maxwell", 2020, Arrays.asList("History", "Politics")),
                new Book("Mystic Lands", "Sarah J. Maas", 2021, Arrays.asList("Fantasy", "Adventure")),
                new Book("The Java Handbook", "Joshua Bloch", 2020, Arrays.asList("Programming", "Technology")),
                new Book("Galactic Wars", "Isaac Asimov", 2021, Arrays.asList("Sci-Fi", "Adventure")),
                new Book("Healthy Living", "Jane Smith", 2022, Arrays.asList("Health", "Self-help")),
                new Book("Code Clean", "Robert C. Martin", 2022, Arrays.asList("Programming", "Productivity")),
                new Book("World Atlas", "Rand McNally", 2020, Arrays.asList("Geography", "Reference")),
                new Book("The Power of Mind", "Deepak Chopra", 2021, Arrays.asList("Self-help", "Spirituality"))
        );

        Map<Integer, Set<String>> finalGenreDetails = books.stream()
                .collect(Collectors.groupingBy(book -> book.getYearPublished(),
                        Collectors.flatMapping(book -> book.getGenres().stream(), Collectors.toSet())

                ));
        System.out.println("Group all books by their publication year \n" +
                "For each year, extract all unique genres of books published in that year\n"+"{ ");
        finalGenreDetails.forEach((year,genreSet)->{

            System.out.println( indent(2) +"Year : "+ year);
            System.out.println( indent(2)+"Genre : \n"+indent(3)+"{");
            genreSet.forEach(genre-> System.out.println(indent(4)+genre));
            System.out.println(indent(3)+"}");
            System.out.println();
        });
        System.out.println("}");






    }
}
